/**
 *  Host repertoire model
 */

/*---------------- Built-in types -----------------------------*/
// We are assuming that the built-in tree type is structured as follows.  We do
// not think this should be part of the script. Note that this tree is a binary
// time tree, which is perhaps the most useful type of tree, but we will need
// to support other tree types as well.
type Tree =
    | Leaf{age: Real, label: String}
    | Node{age: Real, left: Tree, right: Tree, label: String}

/*---------------- Model-specific types -----------------------------*/

// TODO: type definition in CorePPL
//type ModelParams = 
//  ModelParams{q: Tensor[Real], d_matrix: Tensor[Real], d_average: Real, beta: Real}

// Tree decorated with postorder messages from belief propagation.
// Postorder = backwards in time
type MsgTree =
 | MsgLeaf{age: Real, label: String, out_msg: Real[][3]}
 | MsgNode{age: Real, label: String, left: MsgTree, right: MsgTree,
           left_in_msg: Real[][3], right_in_msg: Real[][3], out_msg: Real[][3]}

// TODO: Real[][3] - generalise to any number of states? 

// Tree decorated with final probabilities from belief propagation,
// tuned so that they are useful for proposals.
type ProbsTree =
 | ProbsLeaf{age: Real, label: String, probs: Real[][3]}
 | ProbsNode{age: Real, label: String, probs: Real[][3],
             left: ProbsTree, right: ProbsTree}

// Event type used to store information about one host-repertoire change
// We keep the from_state here just in case we want to use it for debugging
type Event = Event{age: Real, host: Int, from_state: Int, to_state: Int}

// Type used to hold a proposed history of state changes for a branch
type ProposedHistory = ProposedHistory{log_debt: Real, events: Event[]}

// History point type used to store repertoire snapshots at the repertoire
// start ages repertoire start age = time of the event that led to that
// combination
type HistoryPoint = HistoryPoint{age: Real, repertoire: Int[]}

// HistoryScore type used to store a vector of history points and a log
// score associated with this history.
type HistoryScore = HistoryScore{log_score: Real, history: HistoryPoint[]}

// Tree decorated with ancestral host repertoires and branch repertoire histories
type HistoryTree =
  | HistoryLeaf{age: Real, label: String, repertoire: Int[], history: HistoryPoint[], log_rep_debt: Real}
  | HistoryNode{age: Real, label: String, repertoire: Int[], history: HistoryPoint[], log_rep_debt: Real,
                left: HistoryTree, right: HistoryTree}


/**
 *  Model
 *
 *  @param lambda: vector of transition rates. lambda[1]: switch_rate_0_to_1,
 *  lambda[2]: switch_rate_1_to_0 lambda[3]: switch_rate_1_to_2, lambda[4]:
 *  switch_rate_2_to_1. Transition rates are given as proportions of the total
 *  off-diagonal rate, that is, the sum of lambdas is 1.0.
 *  @param mu: rescale all rates in lambda with mu. Referred to as the maximum
 *  rate (or rate, for short) of host repertoire evolution, since
 *  0≤mu*lambda_i≤mu for all i (all lambdas <= 1.0).
 *  @param beta: phylogenetic distance parameter, determining strength of the
 *  host distance effect on host repertoire evolution.
 * 
 */


model function mymodel(parasite_tree: Tree, ntips: Int, nhosts: Int, interactions: String[],
  host_distances: Real[], d_average: Real, tune: Real): HistoryTree {

  // Set priors for model parameters
  //assume lambda ~ Dirichlet(1.,1.,1.,1.); //TODO: Check if Dirichlet is available
  let lambda = [0.25,0.25,0.25,0.25];
  assume mu ~ Exponential(10.);
  assume beta ~ Exponential(1.);

  //printLn(real2string(lambda[1]));

  // Set transition rate matrix for three-state independence model. We assume
  // that we can multiply a matrix by a scalar.
  // DONE: Check that we can name variables with capital letters: we can't
  let r = matrixCreate([3,3],
    [0.-lambda[1],                lambda[1],          0.0,
        lambda[2], 0.-(lambda[2]+lambda[3]),    lambda[3],
              0.0,                lambda[4], 0.-lambda[4]]
  );
  let q = matrixMulFloat(mu,r);

  printLn(real2string(0.-lambda[1]));

  // Package model parameters into an object for convenient calling
  // Note that during preprocessing we need to calculate d_average and
  // make sure that host order in interactions and host distances
  // match, regardless of whether the input order is the same.

  let d = matrixCreate([nhosts,nhosts],host_distances);
  //let mp = ModelParams ( q=q, d_matrix=d, d_average=d_average, beta=beta); //TODO: Check if ModelParams exists
  
  // Derive params for ancestral repertoire proposals from independence model
  //let i = matrixCreate([ntips,nhosts],interactions); // TODO: extend matrixCreate to take Char as well
  //let probs_tree = get_proposal_params (parasite_tree, i, q, tune);

  // Propose a repertoire for the root of the parasite tree
  //rep: Int[]
  //log_rep_debt = 0.0
  //for i in 1 to n_hosts {
  //    assume rep[i] ~ Categorical (probs_tree.probs[i], [0,1,2]) //TODO: syntax check
  //    log_rep_debt += Categorical(probs_tree.probs[i], [0,1,2]).score(rep[i]) //QUESTION: I don't understand .score(rep[i])
  //}




  let myHistoryTree = HistoryLeaf {age = 10.0, label = "bbb", repertoire = [1,2], history = [HistoryPoint{age = 12.0, repertoire = [1,2]}], log_rep_debt = 0.2};
  return myHistoryTree;
}