/*
 *  Host repertoire model
 *  
 * This file implements the host repertoire model described by Braga et al
 *  2020 (https://doi.org/10.1093/sysbio/syaa019).
 *
 * This version explicitly repays weight associated with proposal
 * 
 * Compile 
 * tpplc host_repertoire.tppl -m smc-apf  
 * 
 * Run
 * ./out treeppl/models/data/hostrep.json 10 1
 */

/*---------------------------- TYPES --------------------------------*/

// TreeLabeled is like the built in Tree type, but with leaf and node labels
type TreeLabeled =
    | Leaf{age: Real, label: Int}
    | Node{age: Real, left: TreeLabeled, right: TreeLabeled, label: Int}

/*-------------------- Model-specific types -------------------------*/

type ModelParams = 
  ModelParams{qMatrix: Tensor[Real], dMatrix: Tensor[Real], dMean: Real, beta: Real}

// Tree decorated with postorder messages from belief propagation.
// Postorder = backwards in time
type MsgTree =
 | MsgLeaf{age: Real, label: Int, out_msg: Tensor[Real][]}
 | MsgNode{age: Real, label: Int, left: MsgTree, right: MsgTree,
           left_in_msg: Tensor[Real][], right_in_msg: Tensor[Real][], out_msg: Tensor[Real][]}

// Tree decorated with final probabilities from belief propagation,
// tuned so that they are useful for proposals.
type ProbsTree =
 | ProbsLeaf{age: Real, label: Int, probs: Tensor[Real][]}
 | ProbsNode{age: Real, label: Int, probs: Tensor[Real][],
             left: ProbsTree, right: ProbsTree}

// Event type used to store information about one host-repertoire change
// We keep the from_state here just in case we want to use it for debugging
type Event = Event{age: Real, host: Int, from_state: Int, to_state: Int}

// Type used to hold a proposed history of state changes for a branch
type ProposedHistory = ProposedHistory{log_debt: Real, events: Event[]}

// History point type used to store repertoire snapshots at the repertoire
// start ages, which is the time of the event that led to that combination
type HistoryPoint = HistoryPoint{age: Real, repertoire: Int[]}

// HistoryScore type used to store a vector of history points and a log
// score associated with this history.
type HistoryScore = HistoryScore{log_score: Real, history: HistoryPoint[]}

// Tree decorated with ancestral host repertoires and branch repertoire histories
type HistoryTree =
  | HistoryLeaf{age: Real, label: Int, repertoire: Int[], history: HistoryPoint[], log_rep_debt: Real}
  | HistoryNode{age: Real, label: Int, repertoire: Int[], history: HistoryPoint[], log_rep_debt: Real,
                left: HistoryTree, right: HistoryTree}

// Type used to hold the character histories and parameter values to be outputed
type ReturnType = ReturnType{tree: HistoryTree, lambda: Real[], mu: Real, beta: Real}

/*
 *  Model
 *
 *  @param lambda: vector of transition rates 
 *  lambda[1]:0->1, lambda[2]:1->0, lambda[3]:1->2, lambda[4]:2->1 
 *  Transition rates are given as proportions of the total
 *  off-diagonal rate, that is, the sum of lambdas is 1.0
 * 
 *  @param mu: rescale all rates in lambda with mu. Referred to as the maximum
 *  rate (or rate, for short) of host repertoire evolution, since
 *  0≤mu*lambda_i≤mu for all i (all lambdas <= 1.0).
 * 
 *  @param beta: phylogenetic distance parameter, determining strength of the
 *  host distance effect on host repertoire evolution.
 */

model function mymodel(symbiont_tree: TreeLabeled, ntips: Int, nhosts: Int, interactions: Int[],
  host_distances: Real[], dMean: Real, tune: Real): ReturnType {

  // Set priors for model parameters
  assume lambda ~ Dirichlet([1.0,1.0,1.0,1.0]); 
  assume mu ~ Exponential(10.0);
  assume beta ~ Exponential(1.0);

  // Set transition rate matrix for three-state independence model
  let r = mtxCreate(3,3,
    [0.-lambda[1],                lambda[1],          0.0,
        lambda[2], 0.-(lambda[2]+lambda[3]),    lambda[3],
              0.0,                lambda[4], 0.-lambda[4]]
  );
  let qMatrix = mtxSclrMul(mu, r);

  // Calculate stationary probabilities for the rate matrix q
  let stationary_probs = stationaryProbs(lambda);

  let dMatrix = mtxCreate(nhosts, nhosts, host_distances);

  // Package model parameters into an object for convenient calling
  let mp = ModelParams{qMatrix = qMatrix, dMatrix = dMatrix, dMean = dMean, beta = beta};

  let interactions_reals = sint2real(interactions);
  let iMatrix = mtxCreate(ntips, nhosts, interactions_reals);

  // Derive params for ancestral repertoire proposals from independence model
  let probs_tree = get_proposal_params(symbiont_tree, iMatrix, qMatrix, stationary_probs, tune);

  // Propose a repertoire for the root of the symbiont tree
  // based on the state probabilities from the belief propagation
  let probRecordSequence = sapply(probs_tree.probs, createProbRecord);
  let root_rep = sapply(probRecordSequence, categorical);

  let log_root_rep_debt = seqSumReal(zipWith(categoricalLogScore, root_rep, probRecordSequence));
	// Note: categorical works here because root_rep id 0-based

  let valid_root = any(is2, root_rep);

  if !valid_root { 
    weight 0.0; 
    resample;
  } 
 
  let log_score_root = - ( log( (3.0 ^ Real(nhosts)) - (2.0 ^ Real(nhosts)) ) );


  // Simulate repertoire history on the symbiont tree (left and right daughters)
  let left = simulate(probs_tree.left, HistoryPoint{age = probs_tree.age, repertoire = root_rep}, mp, iMatrix);
  let right = simulate(probs_tree.right, HistoryPoint{age = probs_tree.age, repertoire = root_rep}, mp, iMatrix);

  // Root node doesn't have any history (no subroot branch)
  let historyTree = HistoryNode{age = probs_tree.age, label = probs_tree.label,
    repertoire = root_rep, history = [], log_rep_debt = log_root_rep_debt-log_score_root,
    left = left, right = right};

  // Factor in the net debt of the proposed ancestral repertoires 
  // at nodes and leaves in the historyTree
  logWeight( -get_rep_debt(historyTree) );
  
  // Return symbiont tree with simulated character history and parameter values
  return ReturnType{tree = historyTree, lambda = lambda, mu = mu, beta = beta};
} 


/*---------------------------- FUNCTIONS --------------------------------*/


/*---------------- Proposal distribution parameters ---------------------*/

/*
 * get_proposal_params
 *
 * This functions uses belief propagation under the independence
 * model, and an anneling parameter 'tune', to obtain parameters
 * for the proposals of ancestral repertoires.
 *
 * Parameters:
 *   @param symbiont_tree: symbiont tree
 *   @param iMatrix: interaction matrix
 *   @param qMatrix: rate matrix for the independence model
 *   @param stationary_probs: stationary probabilities for the independence model
 *   @param tune: parameter in (0,1) determining how much
 *                we should trust the independence model
 *
 * Return value:
 *   A ProbsTree containing the final repertoire state proposal
 *   probabilities for all nodes in the symbiont tree.
 */
function get_proposal_params(symbiont_tree: TreeLabeled, iMatrix: Tensor[Real], qMatrix: Tensor[Real], 
  stationary_probs: Tensor[Real], tune: Real): ProbsTree {

  let msgTree = postorder_msgs(symbiont_tree, iMatrix, qMatrix);  
  let n = length(getMsgTreeMsg(msgTree));
  let pis = rep(n, stationary_probs);
  return final_probs(msgTree, pis, qMatrix, tune);

}

// Compute postorder messages on the observed tree
function postorder_msgs(tree: TreeLabeled, iMatrix: Tensor[Real], qMatrix: Tensor[Real]) : MsgTree {

  if tree is Leaf {
    return MsgLeaf{age = 0.0, label = tree.label, out_msg = observationMessage(mtxGetRow(tree.label, iMatrix))};
  }

  let left  = postorder_msgs(tree.left ,iMatrix, qMatrix);
  let right = postorder_msgs(tree.right,iMatrix, qMatrix);

  let tMatrixLeft = mtxTrans(mtxExp(mtxSclrMul(tree.age-left.age, qMatrix)));   
  let tMatrixRight = mtxTrans(mtxExp(mtxSclrMul(tree.age-right.age, qMatrix)));

  let left_in_msg  = sapply1(left.out_msg, mtxMul, tMatrixLeft);
  let right_in_msg = sapply1(right.out_msg, mtxMul, tMatrixRight);

  let out_msg = normalizeMessage(mulMessage(left_in_msg, right_in_msg));

  return MsgNode{age= tree.age, label= tree.label, left= left, right= right, 
    left_in_msg = left_in_msg, right_in_msg = right_in_msg, out_msg = out_msg};

}

// Compute leaf message from observed interactions
function observationMessage(obs_repertoire: Tensor[Real]) : Tensor[Real][] {
  return tapply(obs_repertoire, makeStateMessage);                         
}

// Takes a single interaction and creates the message
// Interactions are of type Real because of limitations in boolean comparisons
function makeStateMessage(interaction: Real): Tensor[Real] {
  // NOTE: we do not have a switch statement, perhaps we need in the future?

  if (interaction == 0.0) {
    return rvecCreate(3, [1., 0., 0.]);
  } else {
    	if (interaction == 1.0) {
    		return rvecCreate(3, [0., 1., 0.]);
    	} else {
      		if (interaction == 2.0) {
    				return rvecCreate(3, [0., 0., 1.]);
					} else {
    				return rvecCreate(3, [1., 1., 1.]);
						}
				}
		}
}

// Compute final probabilities from belief propagation on the observed symbiont tree
function final_probs(tree: MsgTree, parent_msg: Tensor[Real][], qMatrix: Tensor[Real], tune: Real) : ProbsTree {
    
  let probs = normalizeMessage(
		messageElementPower(mulMessage(tree.out_msg, parent_msg), tune)
  );

  if tree is MsgLeaf {
    return ProbsLeaf{age= 0.0, label= tree.label, probs = probs};
  } 

  let left_branch = tree.age - getMsgTreeAge(tree.left);
  let right_branch = tree.age - getMsgTreeAge(tree.right);

  let tMatrixLeft = mtxExp(mtxSclrMul(left_branch, qMatrix));
  let tMatrixRight = mtxExp(mtxSclrMul(right_branch, qMatrix));

  let left_parent_msg  = sapply1(mulMessage(parent_msg,tree.left_in_msg), mtxMul, tMatrixLeft);
  let right_parent_msg = sapply1(mulMessage(parent_msg,tree.right_in_msg), mtxMul, tMatrixRight);

  let left  =  final_probs(tree.left,  left_parent_msg, qMatrix, tune);
  let right =  final_probs(tree.right, right_parent_msg, qMatrix, tune);

  return ProbsNode{age = tree.age, label = tree.label, left = left, right = right, probs = probs};
}


/*---------------- Model functions -------------------------*/

// Simulate an evolutionary history for the host repertoires, from root to leaves
function simulate (tree: ProbsTree, start: HistoryPoint, mp: ModelParams, iMatrix: Tensor[Real]) : HistoryTree {
    
  // Propose a repertoire. The propose mechanism means that the simulation
  // should be "penalized" for the probability associated with the draw. 
  let probs = getProbs(tree);  // TODO: is this needed?
  let probRecordSequence = sapply(tree.probs, createProbRecord);
  let repertoire = sapply(probRecordSequence, categorical);      // Note: assume is within function categorical
    
  let log_rep_debt = seqSumReal(zipWith(categoricalLogScore, repertoire, probRecordSequence)); 
	// Note: categorical works here because repertoire id 0-based
  	
  let valid_rep = any(is2, repertoire);  
  if !valid_rep { 
    weight 0.0; 
    resample;
  } 

	let stop = HistoryPoint{age = getProbsTreeAge(tree), repertoire = repertoire};
	let history = simulate_history(start, stop, mp);
  
	if tree is ProbsLeaf {

		let obs_msg = observationMessage(mtxGetRow(tree.label, iMatrix)); 
		let obsRecordSequence = sapply(obs_msg, createProbRecord);
		let log_score = seqSumReal(zipWith(categoricalLogScore, repertoire, obsRecordSequence));
		// Note: categorical works here because repertoire id 0-based
		
		return HistoryLeaf{age = tree.age, label = tree.label, repertoire = repertoire, 
		                   history = history, log_rep_debt = log_rep_debt - log_score};
	}

	let left = simulate(tree.left, stop, mp, iMatrix);
	let right = simulate(tree.right, stop, mp, iMatrix);

	return HistoryNode{age = tree.age, label = tree.label, repertoire = repertoire,
					   history = history, log_rep_debt = log_rep_debt,
					   left = left, right = right};

}


// Simulate history conditional on initial repertoire, start time, and end
// time. We first propose events from the independence model and then
// condition the simulation on those events.
function simulate_history (from_rep: HistoryPoint, to_rep: HistoryPoint, mp: ModelParams) : HistoryPoint[] {

  let proposed_unordered_events = propose_events(1, from_rep, to_rep, mp.qMatrix);
  // order events by decreasing age
	let eventSeq = qSort(subAge, proposed_unordered_events.events);
  // Simulate repertoire evolution from full model, one event at a time
  let history_score = simulate_by_event(from_rep.repertoire, eventSeq, 1, from_rep.age, 
    to_rep.age, mp, proposed_unordered_events.log_debt);
	
  // Now we have both debt and score at an alignment point 
  logWeight(history_score.log_score - proposed_unordered_events.log_debt); 

  return history_score.history;
}

// Propose events from independence model
function propose_events (host_index: Int, from_rep: HistoryPoint, to_rep: HistoryPoint, qMatrix: Tensor[Real]) : ProposedHistory {

  // End case, have already done all hosts ins the repertoire
  if (gti(host_index, length(from_rep.repertoire))) {            
		return ProposedHistory{log_debt = 0.0, events = []};       
	}
  let propHist1 = propose_events_for_host(host_index, from_rep.age, to_rep.age, 
		from_rep.repertoire[host_index], to_rep.repertoire[host_index], qMatrix);

  let propHist2 = propose_events(addi(host_index, 1), from_rep, to_rep, qMatrix);

  return ProposedHistory{log_debt = propHist1.log_debt + propHist2.log_debt, 
												 events = join([propHist1.events, propHist2.events])};

	}

// Propose events for one host
function propose_events_for_host (host_index: Int, from_age: Real, end_age: Real,
	from_state: Int, end_state: Int, qMatrix: Tensor[Real]) : ProposedHistory {
		
	let rate = -(mtxGet(addi(from_state,1), addi(from_state,1), qMatrix));
  
  // Kill the particle if we are trying to subdivide a time segment that
  // is too short. This will come with a big penalty in either case but
  // continuing to run the code will result in numerical problems like
  // sampling waiting times that are -0. and getting debts that are inf,
  // both of which are difficult to handle.
  if (rate * (from_age - end_age) < 1E-15 && !eqi(from_state,end_state)) {
    weight 0.0;
    resample;
  }

  let t = getWaitingTime(from_state, end_state, rate, from_age, end_age);
	let new_age = from_age - t;

	// Calculate debt. Note the special case for the last time segment
	// with no events. We use the average weight of all particles with
	// this outcome, which should be advantageous for inference
	// efficiency. It also saves us from storing the actual draw.
	if (new_age < end_age) {
		let log_wait_debt = poissonLogScore(0, PoissonParam{rate = rate*(from_age - end_age)});
		return ProposedHistory{log_debt = log_wait_debt, events = []};
	}

  let log_wait_debt = getLogWaitDebt(from_state, end_state, rate, from_age, end_age, t);
	let to_states = getToStates(from_state); 
	let state_probs = seqNormalize([mtxGet(addi(from_state,1), addi(to_states[1],1), qMatrix),
																	mtxGet(addi(from_state,1), addi(to_states[2],1), qMatrix)]);
	
	assume new_state_pos ~ Categorical(state_probs);
	let new_state = to_states[addi(new_state_pos, 1)];
  // Note: Categorical is 0-based, so we need to add 1 do get the correct position
	let log_event_debt = categoricalLogScore(new_state_pos, CategoricalParam{probs = state_probs}); 
  // Note: Use position instead of value

	let event = Event{age = new_age, host = host_index, from_state = from_state, to_state = new_state};
	let propHist = propose_events_for_host(host_index, new_age, end_age, new_state, end_state, qMatrix);

	return ProposedHistory{log_debt = log_wait_debt+log_event_debt+propHist.log_debt, events = join([[event], propHist.events])};

}

function getLogWaitDebt(from_state: Int, end_state: Int, rate: Real, from_age: Real, end_age: Real, t: Real): Real {
	if (!eqi(from_state,end_state)) {
		return log_pdf_exponential_max_t(t, rate, from_age - end_age);
	} else {
		return exponentialLogScore(t, ExponentialParam{rate = rate}); 
	}
}

function getWaitingTime(from_state: Int, end_state: Int, rate: Real, from_age: Real, end_age: Real): Real {
	if (!eqi(from_state,end_state)) {
		return sample_exponential_max_t(rate, from_age - end_age);
	} else {
		assume t ~ Exponential(rate);
    return t;
	}
}

function getToStates(state: Int): Int[] { 
	if (Real(state) == 0.0) {
		return [1,2];
	} else {
		if (Real(state) == 1.0) {
			return [0,2];
		} else {
			if (Real(state) == 2.0) {
				return [0,1];
			} else {
        return error("Invalid state");
      }
		}
	}
}

// Sample from truncated exponential distribution with rate 'rate'
// but with support only on (0, max_t).
function sample_exponential_max_t(rate: Real, max_t: Real) : Real {
  let u_min = exp (-(rate * max_t));
  assume u ~ Uniform (u_min, 1.0);
  return ((-(log(u))) / rate);
}

// Compute log PDF for a value from the truncated exponential
// The truncation multiplies the pdf with 1/(1-u_min).
function log_pdf_exponential_max_t(value : Real, rate: Real, max_t: Real) : Real {
	let u_min = exp(-(rate * max_t));
  return ( (-(rate * value * log(rate))) - log(1.0-u_min)); 
}

// Simulate repertoire evolution from full model, one event
// at a time. We return the sequence of repertoires. We
// accumulate scores here rather than introducing observe
// statements, as those observes would not be aligned.
function simulate_by_event (repertoire: Int[], eventSeq: Event[], event_index: Int,
	from_age: Real, end_age: Real, mp: ModelParams, log_debt: Real) : HistoryScore {

	// End case, deal with last time segment
	if gti(event_index, length(eventSeq)) {          
		let change_rate = total_rate(repertoire, mp);
		return HistoryScore{log_score = poissonLogScore(0, 
      PoissonParam{rate = change_rate*(from_age-end_age)}), history = []};
	}

	// Typical case
	let the_event = eventSeq[event_index];
	let rate = getRate(repertoire, the_event.host, the_event.to_state, mp);
	let change_rate = total_rate(repertoire, mp);

	// Note that the first statement will capture the cases where the proposed
	// history is impossible because the repertoire we are supposed to go to is
	// empty (the rate is zero).
	if (rate == 0.0) {
    weight 0.0;
    resample;
  }
  let exp_log_prob = exponentialLogScore(from_age - the_event.age, ExponentialParam{rate=change_rate});
  let logScore = exp_log_prob + log(rate/change_rate);

  // Update repertoire with the change in the_event
  let new_repertoire = sapplyi1(repertoire, getNewState, the_event);
	let hp = HistoryPoint{age = the_event.age, repertoire = new_repertoire};
  // Simulate next event
	let simHist = simulate_by_event(new_repertoire, eventSeq, addi(event_index,1), the_event.age, end_age, mp, log_debt);

	return HistoryScore{log_score = simHist.log_score + logScore, history = join([simHist.history, [hp]])};
}

// Update host states
function getNewState(i: Int, state: Int, event: Event): Int {
	if ( eqi(i, event.host) ) {
	  return event.to_state;
	} else {
	  return state;
	}
}

// Compute rate for a proposed event
function getRate (repertoire: Int[], host_index: Int, to_state: Int, mp: ModelParams): Real {

  let from_state = repertoire[host_index];
  let base_rate = mtxGet(addi(from_state,1), addi(to_state,1), mp.qMatrix);

  // Losses are easy, no cross-repertoire modification used here
  if (gti(from_state, to_state)) {
		
		let n2s = fold(count2s, 0, repertoire);
		if (eqi(from_state, 2) && Real(n2s) == 1.0) { 
			return 0.0;
		} else {
			return base_rate;
		}
	} else {
    
    // We have a gain rate, so we need to factor in beta-dependent cross-repertoire effect
    if (eqi(from_state, 0)) {
      let current_hosts = whichTrue(sapply(repertoire, is1or2)); 
      let dist = tensorMean(mtxRowCols(mp.dMatrix, host_index, current_hosts));
      return base_rate * (exp(-(mp.beta*(dist/mp.dMean))));

    } else {
      let current_hosts = whichTrue(sapply(repertoire, is2));   
      let dist = tensorMean(mtxRowCols(mp.dMatrix, host_index, current_hosts));
      return base_rate * (exp(-(mp.beta*(dist/mp.dMean))));
    }
  }
}

// Compute total rate of change from a repertoire
function total_rate (repertoire: Int[], mp: ModelParams): Real {

	let n1s = fold(count1s, 0, repertoire);
	let totalLoss1 = Real(n1s) * mtxGet(2, 1, mp.qMatrix);
	let n2s = fold(count2s, 0, repertoire);
	let totalLoss2 = getLoss2(Real(n2s), mp);

  let gainsSeq = sapplyi2(repertoire, gainsIf0or1, repertoire, mp);
	let totalGains = seqSumReal(gainsSeq);

  return totalLoss1 + totalLoss2 + totalGains;
}

function getLoss2 (n2s: Real, mp: ModelParams): Real {
  if n2s <= 1.0 {
		let totalLoss2 = 0.0;
    return totalLoss2;
	} else {
		let totalLoss2 = n2s * mtxGet(3, 2, mp.qMatrix);
    return totalLoss2;
	}
}

function gainsIf0or1 (i: Int, from_state: Int, repertoire: Int[], mp: ModelParams): Real {
	
	if (eqi(from_state, 0) || eqi(from_state, 1)) {
		return getRate(repertoire, i, addi(from_state,1), mp);
	} else {
		return 0.0;
	}
}

// Accumulate the total log debt of proposing the
// ancestral repertoires in the tree.
function get_rep_debt (tree: HistoryTree): Real {

  if tree is HistoryLeaf {
		return tree.log_rep_debt;
	} else{
			return  get_rep_debt(tree.left) + get_rep_debt(tree.right);
	}
}


/*---------------- Help functions --------------------------*/


function createProbRecord(p: Tensor[Real]): CategoricalParam {
  // This version works on tests, but not here
  // let ncol = dim(p)[2];
	// let ps = rep(ncol, p);
	// let p_seq = zipWith(getRowVecElem, ps, 1 to ncol); 

  // Hard-coded version
  let p1 = getRowVecElem(p, 1);                
	let p2 = getRowVecElem(p, 2);
	let p3 = getRowVecElem(p, 3);
	let p_seq = [p1,p2,p3];
  return CategoricalParam {probs = p_seq};
}

function getRowVecElem(t: Tensor[Real], i: Int): Real {
  return mtxGet(1, i, t);
}

// Calculate stationary probabilities from lambda values
function stationaryProbs(lambda: Real[]): Tensor[Real] {
  let pi_1 = 1.0 / (1.0 + (lambda[2]/lambda[1]) + (lambda[3]/lambda[4]));
  let pi_0 = pi_1 * (lambda[2]/lambda[1]);
  let pi_2 = 1.0 - pi_0 - pi_1;
  return rvecCreate(3, [pi_0, pi_1, pi_2]);
}
  
function getMsgTreeAge(tree: MsgTree) : Real {
	return tree.age;
}

function getMsgTreeMsg(tree: MsgTree) : Tensor[Real][] {
	return tree.out_msg;
}

function getProbsTreeAge(tree: ProbsTree) : Real {
	return tree.age;
}

function getProbs(tree: ProbsTree): Tensor[Real][]{
	return tree.probs;
}

function subAge(left: Event, right: Event): Int {
  let diff = subf(right.age, left.age);
  if (diff >= 0.0){
    return 1;
  } else {
			return subi(1,2);  // type error if I just write -1
	}
}

function count2s(count: Int, host: Int): Int {
	if (eqi(host, 2)) {
		return addi(count, 1);
	} else {
			return count;
	}
}

function count1s(count: Int, host: Int): Int {
	if (eqi(host, 1)) {
		return addi(count, 1);
	} else {
			return count;
	}
}

function is2(x: Int): Bool {
  if (eqi(x, 2)) {
    return true;
  } else {
      return false;
  }
}

function is1or2(x: Int): Bool {
  if (eqi(x,1) || eqi(x,2)) { 
    return true;
  } else {
			return false;
	}
}