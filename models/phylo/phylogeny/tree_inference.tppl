// Naive TreePPL script for tree inference under the
// Jukes Cantor model with a strict clock prior. This is
// the naive version; for effective inference, belief
// propagation needs to be implemented in the back end.

// Run this by compiling: 
// tpplc models/phylo/phylogeny/tree_inference.tppl -m 'smc-apf' --resample align --output basic_phylo
// And then execution 10000 particles 1 sweep, using for example toy dataset phylo_toydata2_Ints.json.json:
// ./basic_phylo models/data/treeinference/phylo_toydata2_Ints.json 10000 1 > basic_phylo.json

// Toy dataset as json file phylo_toydata2_Ints.json. Integers. 
// Data is a matrix, with each row
// consisting of the aligned DNA sequence for a single
// taxon. The nucleotide is specified as
//   "A" for adenine 0
//   "C" for cytosine 1
//   "G" for guanine 2
//   "T" for thymine 3

// TYPES

type SeqTree =
  | Leaf {age: Real, seq: Int[]}
  | Node {age: Real, seq: Int[], left: SeqTree, right: SeqTree}

// FUNCTIONS

// Build forest of trees from leaves, recursively
function buildForest(data: Int[][], forest: SeqTree[], index: Int, dataLen: Int): SeqTree[]
{ 
    let newLeaf = Leaf{age=0.0, seq=data[index]};
    let new_forest = join([forest, [newLeaf]]);
    if (eqi(dataLen, index)) {
        return new_forest; 
    }
    else {
        return buildForest(data, new_forest, addi(index, 1), dataLen);
    }
}

// Randomly sample two indices in the trees vector, to be combined
function pickpair(n: Int): Int[]
{ 
    assume i ~ Categorical(rep(n, 1./Real(n)));  
    assume j ~ Categorical(rep(n, 1./Real(n)));  
    if (eqi(j, i)) {
        return pickpair(n); 
    }
    return [addi(i, 1), addi(j, 1)]; //adding 1 to avoid index 0
}

//Note: this is not optimal, in terms of repeated calculation of matrix exp
function ctmc(initialstate: Int, q: Tensor[Real], t: Real): Real[]
{ 
    let choices = [[1.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0], [0.0, 0.0, 0.0, 1.0]]; 
    let state = rvecCreate(4, choices[addi(initialstate, 1)]); 
    let p = state *@ (mtxExp(q *$ t)); 
    return[mtxGet(1, 1, p), mtxGet(1, 2, p), mtxGet(1, 3, p), mtxGet(1, 4, p)];
}

function cluster(q: Tensor[Real], trees: SeqTree[], maxAge: Real, seqLen: Int): SeqTree[]
{
    let n = length(trees);

    // Check if we have reached the root of the tree
    if (eqi(n, 1)) {
        return trees;
    }
    // Randomly sample two indices in the trees vector with function pickpair
    // We will combine these, named left and right child
    let pairs = pickpair(n);
    let leftChild = trees[pairs[1]];
    let rightChild = trees[pairs[2]];

    // Get the age of the new internal node
    assume t ~ Exponential(10.0);
    let age = maxAge + t;
    
    // Propose ancestral state(s) from stationary distribution, to be corrected later
    let seq = iid(categorical, CategoricalParam{probs=[0.25, 0.25, 0.25, 0.25]}, seqLen);
    
    // Observe the child states given the proposed state of parent node
    for i in 1 to seqLen {
        let p1 = ctmc(seq[i], q, age-leftChild.age);
        observe leftChild.seq[i] ~ Categorical(p1);
        if (leftChild is Node) {
            logWeight -(categoricalLogScore(leftChild.seq[i], CategoricalParam{probs=[0.25, 0.25, 0.25, 0.25]})); 
        }  
        let p2 = ctmc(seq[i], q, age-rightChild.age);
        observe rightChild.seq[i] ~ Categorical(p2);
        if (rightChild is Node) {
            logWeight -(categoricalLogScore(rightChild.seq[i], CategoricalParam{probs=[0.25, 0.25, 0.25, 0.25]}));
        }  
    }

    // Combine picked pair of trees into a new node
    let parent = Node{age=age, seq=seq, left=leftChild, right=rightChild};  

    // Compute new_trees list
    let min = mini(pairs[1], pairs[2]);  
    let max = maxi(pairs[1], pairs[2]); 
    let new_trees = join([slice(trees, 1, min), slice(trees, addi(min, 1), max), slice(trees, addi(max, 1), addi(n, 1)), [parent]]);

    // Recursive call to cluster for new_trees
    return cluster(q, new_trees, age, seqLen);
}

// MODEL

model function myModel(data: Int[][]) : SeqTree[]
{
    // Define the scaled rate matrix for Jukes-Cantor
    let q = mtxCreate(4,4,
        [     -1.0, (1.0/3.0), (1.0/3.0), (1.0/3.0),
        (1.0/3.0),      -1.0, (1.0/3.0), (1.0/3.0),
        (1.0/3.0), (1.0/3.0),      -1.0, (1.0/3.0),
        (1.0/3.0), (1.0/3.0), (1.0/3.0),      -1.0]
        );        

    let dataLen = length(data);
    let seqLen =  length(data[1]);
    
    // Define the initial trees vector (containing the leaves)
    let trees = buildForest(data, [], 1, dataLen);

    // Build the tree by random clustering and return 
    return cluster(q, trees, 0.0, seqLen);
}