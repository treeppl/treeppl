// Naive TreePPL script for tree inference under the
// Jukes Cantor model with a strict clock prior. This is
// the naive version; for effective inference, belief
// propagation needs to be implemented in the back end.

// Run this by compiling: 
// tpplc models/phylo/phylogeny/tree_inference_naive.tppl -m 'smc-bpf' --resample align --output testphylo
// And then execution 1000 particles 1 sweep, using toy dataset phylo.json:
// ./testphylo models/data/phylo.json 1000 1 > phylo_output.json

// Toy dataset as json file phylo.json. NOTE this should be nucleotides in later version, currently integers
// Data is a matrix of type int, with each row
// consisting of the aligned DNA sequence for a single
// taxon. The nucleotide is specified as
//   "A" for adenine 0
//   "C" for cytosine 1
//   "G" for guanine 2
//   "T" for thymine 3

// TYPES

type SeqTree =
  | Leaf {age: Real, seq: Int[], newick: String}
  | Node {age: Real, seq: Int[], left: SeqTree, right: SeqTree, newick: String}

// FUNCTIONS

// Randomly sample two indices in the trees vector, to be combined
function pickpair(n: Int): Int[]
{ 
    assume i ~ Categorical(rep(n, 1./Real(n)));  
    assume j ~ Categorical(rep(n, 1./Real(n)));  
    if (eqi(j, i)) {
        return pickpair(n); 
    }
    return [addi(i, 1), addi(j, 1)]; //adding 1 to avoid index 0
}

function ctmc(initialstate: Int, q: Tensor[Real], t: Real): Real[]
{ 
    let choices = [[1.0, 0.0, 0.0, 0.0],[0.0, 1.0, 0.0, 0.0],[0.0, 0.0, 1.0, 0.0],[0.0, 0.0, 0.0, 1.0]]; 
    let state = rvecCreate(4,choices[addi(initialstate, 1)]); 
    let p = state*@(mtxExp(q*$t)); 
    return[mtxGet(1, 1, p), mtxGet(1, 2, p), mtxGet(1, 3, p), mtxGet(1, 4, p)];
}

function cluster(q: Tensor[Real], trees: SeqTree[], maxAge: Real, seqLen: Int): SeqTree[]
{
    let n = length(trees);

    // Check that we have not yet reached the root of the tree
    if (eqi(n, 1)) {
        //let finalTree = join(["(", trees.newick[1], ":0.0);"]); //Adding final formatting newick tree
        return trees;//finalTree; //Returning only the final newick tree string
    }
    // Randomly sample two indices in the trees vector with function pickpair
    // We will combine these, named left and right child
    let pairs = pickpair(n);
    let leftChild = trees[pairs[1]];
    let rightChild = trees[pairs[2]];

    // Get the age of the new internal node
    assume t ~ Exponential(10.0);
    let age = maxAge + t;
    
    // Propose ancestral state(s) from stationary distribution, to be corrected later
    let seq = iid(categorical, CategoricalParam{probs=[0.25, 0.25, 0.25, 0.25]}, seqLen);
    
    // Observe the child states given the proposed state of parent node
    for i in 1 to seqLen {
        let p1 = ctmc(seq[i], q, age-leftChild.age);
        observe leftChild.seq[i] ~ Categorical(p1);
        if (leftChild is Node) {
            logWeight -(categoricalLogScore(leftChild.seq[i], CategoricalParam{probs=[0.25, 0.25, 0.25, 0.25]})); 
        }  
        let p2 = ctmc(seq[i], q, age-rightChild.age);
        observe rightChild.seq[i] ~ Categorical(p2);
        if (rightChild is Node) {
            logWeight -(categoricalLogScore(rightChild.seq[i], CategoricalParam{probs=[0.25, 0.25, 0.25, 0.25]}));
        }  
    }

    // Create the next step of the Newick string
    let newickString = join([ "(", leftChild.newick, ":", real2string(age-leftChild.age), ",", rightChild.newick, ":", real2string(age-rightChild.age), ")", "[", join(sint2string(seq)), "]" ]);
    // Combine picked pair of trees into a new node
    let parent = Node{age=age, seq=seq, left=leftChild, right=rightChild, newick=newickString};  

    // Compute new_trees list
    let min = mini(pairs[1], pairs[2]);  
    let max = maxi(pairs[1], pairs[2]); 
    let new_trees = join([slice(trees, 1, min), slice(trees, addi(min, 1), max), slice(trees, addi(max, 1), addi(n, 1)), [parent]]);

    // Recursive call to cluster for new_trees
    return cluster(q, new_trees, age, seqLen);
}

// MODEL

model function myModel(data: Int[][]) : SeqTree[]
{
    // Define the scaled rate matrix for Jukes-Cantor
    let q = mtxCreate(4,4,
        [     -1.0, (1.0/3.0), (1.0/3.0), (1.0/3.0),
        (1.0/3.0),      -1.0, (1.0/3.0), (1.0/3.0),
        (1.0/3.0), (1.0/3.0),      -1.0, (1.0/3.0),
        (1.0/3.0), (1.0/3.0), (1.0/3.0),      -1.0]
        );        

    // Define the initial trees vector (containing of the leaves)
    // NOTE need to add a function that replaces A,C,G,T with integers and handles uncertain positions, and creates the tree vector.
    let trees = [
        Leaf{age=0.0, seq=data[1], newick=join([join(sint2string(data[1]))])}, //alternative with brackets, as internal nodes currently: newick=join(["[", join(sint2string(data[1])), "]" ])
        Leaf{age=0.0, seq=data[2], newick=join([join(sint2string(data[2]))])}, 
        Leaf{age=0.0, seq=data[3], newick=join([join(sint2string(data[3]))])}, 
        Leaf{age=0.0, seq=data[4], newick=join([join(sint2string(data[4]))])} 
    ];

    let seqLen = 15; //NOTE This should be automatic using length() in next version. 

    // Build the tree by random clustering and return 
    return cluster(q, trees, 0.0, seqLen);
}
