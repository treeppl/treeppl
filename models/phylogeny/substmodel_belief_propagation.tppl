// Hypothetical TreePPL script for inference substitution
// model parameters of the GTR + Gamma model for a fixed
// tree. Here we use explicit belief propagation, which should
// produce a state-of-the-art model with MCMC, using
// suitable drift kernels, slice sampling, or with HMC.

// DATA

// Data is a matrix of type character, with each row
// consisting of the aligned DNA sequence for a single
// taxon. The nucleotide is specified as
//   "A" for adenine
//   "C" for cytosine
//   "G" for guanine
//   "T" for thymine
//   "?" for any of the above
//   "-" a gap, usually treated the same as "?"
// IUPAC has single-character codes for all possible
// combinations of the four nucleotides, but typically
// only those given above are used.
data = [ ["C", "C", "A", "G", "T", "A", "A", "A", "A", "T", "C", "C", "T", "T", "G"],
         ["C", "C", "A", "G", "A", "C", "A", "A", "A", "T", "C", "A", "C", "C", "A"],
         ["A", "A", "C", "C", "A", "G", "C", "A", "A", "A", "G", "A", "T", "T", "A"],
         ["A", "A", "C", "C", "A", "T", "A", "C", "A", "A", "G", "G", "T", "C", "A"]]

// TYPES

// A message is simply four Real values corresponding to the conditional likelihoods
// (unscaled probabilities) of the four different states (A, C, G, T).
type Message = Real[4]

type Tree =
    | Leaf(age: Real, index: Int)
    | Node(age: Real, left: Tree, right: Tree)

// For now, the type RateMatrix can be treated
// as a Real matrix, but we might want to give
// it additional properties in the future
type RateMatrix = Real[][]


// MODEL FUNCTIONS

// A help function to compute the scaled rate matrix for GTR
function gtr(pi:Real[], r:Real[]) : RateMatrix {
    
    // Construct a matrix of exchangeability rates

    unscaled_q = [ [ -(pi[2]*r[1]+pi[3]*r[2]+pi[4]*r[3]),                          pi[2]*r[1],                          pi[3]*r[2],                          pi[4]*r[3] ],
                   [                          pi[1]*r[1], -(pi[1]*r[1]+pi[3]*r[4]+pi[4]*r[5]),                          pi[3]*r[4],                          pi[4]*r[5] ],
                   [                          pi[1]*r[2],                          pi[2]*r[4], -(pi[1]*r[2]+pi[2]*r[4]+pi[4]*r[6]),                          pi[4]*r[6] ],
                   [                          pi[1]*r[3],                          pi[2]*r[5]],                         pi[3]*r[6], -(pi[1]*r[3]+pi[2]*r[5]+pi[3]*r[6]) ] ]

    scaler = 0.0             
    for (i in 1:nrow(rates))
        scaler+= -(unscaled_q[i][i] * pi[i]: RateMatrix )

    return unscaled_q * (1.0/scaler)
}   

// A simple help function to compute a message for a branch in the tree in a
// postorder traversal towards the root. We assume standard conventions here
// for the structure of q with respect to time (rows = from-states)
function message(start_msg: Message[], q: RateMatrix, time: Real) : Message[]
{
    trans_matrix = transpose(matrix_exponential(q*time))

    // Assuming that a vector is treated as a column vector in matrix operations
    end_msg = Message[length(start_msg)]
    for (i=1 to length(end_msg))    // Using R-like syntax for illustration, we need to sequence length here
        end_msg[i] = matrix_multiplication(start_msg[i],trans_matrix)

    return end_msg
}

// Compute postorder messages on the observed tree
function compute_postorder_message(tree: Tree, data: Character[][], clock_rate: Real, q: RateMatrix) : Message[]
{
    if tree is Leaf
        return observation_message(data[tree.index])

    left_msg  = message( compute_postorder_message(tree.left , data, clock_rate, q), q, clock_rate*(tree.left.age -tree.age) )
    right_msg = message( compute_postorder_message(tree.right, data, clock_rate, q), q, clock_rate*(tree.right.age-tree.age) )

    return element_wise_product(left_msg * right_msg)
}

// We need a function computing the message for leaves.
function observe_message(seq_data: Character[]) : Message[] {

    msg = Message[length(seq_data)]

    for (i in 1:length(seq_data)) {

        switch(seq_data[i]) :
            case "A" : msg[i] = [1.0, 0.0, 0.0, 0.0]
            case "C" : msg[i] = [0.0, 1.0, 0.0, 0.0]
            case "G" : msg[i] = [0.0, 0.0, 1.0, 0.0]
            case "T" : msg[i] = [0.0, 0.0, 0.0, 1.0]
            case "?", case "-" : msg[i] = [1.0, 1.0, 1.0, 1.0]
            default : ERROR("Input data incorrect") 
    }
    return msg;
}

// MODEL

function model(data: Character[][], tree: Tree, clock_rate: Real) : type Sample(stationary_probs: Real[], exchangeability_rates: Real[], site_rates: Real[])
{
    // For convience, get the number of sites in the alignment
    n_sites = ncol(data)

    // Sample stationary probs and exchangeability rates and
    // compute the  scaled rate matrix for the GTR model.
    
    // We assume nucleotides (A,C,G,T) represented by ints (0,1,2,3)
    assume pi ~ Dirichlet(alpha=[1,1,1,1],values=[0,1,2,3])     
    
    // We assume exchangeability rates being [r_AC, r_AG, r_AT, r_CG, r_CT, r_GT]
    // according to convention
    assume er ~ Dirichlet(alpha=[1,1,1,1,1,1],values=seq(1,6))

    q = gtr(pi, er) // compute the rate matrix

    // Assume a discrete approximation of gamma for rates across sites
    // Using R syntax for the quantiles of the exponential distribution
    assume alpha ~ Exponential(10)
    n_rate_cats = 4
    cat_rates = [qgamma(p=0.125,k=alpha,theta=1/alpha),
                 qgamma(p=0.375,k=alpha,theta=1/alpha),
                 qgamma(p=0.625,k=alpha,theta=1/alpha),
                 qgamma(p=0.875,k=alpha,theta=1/alpha)]
    cat_probs = [0.25, 0.25, 0.25, 0.25]

    rate_msgs = Message[][]
    for (i in 1:n_rate_cats)
        rate_msgs[i] = compute_postorder_message(tree, data, clock_rate*cat_rates[i], q) * cat_probs[i]

    // Compute the likelihood weight from the root message
    // Integrate out rates and ancestral states in the process
    // The stationary probabilities for this process are pi
    // but we need to transpose pi to a column vector for the
    // matrix multiplication to work as intended.
    pi_col = transpose(pi)
    site_msgs = element_wise_sum(rate_msgs)     // Compute elementwise sum over the first dimension in rate_msgs
    log_likes = Real[n_sites]
    for (i in 1:n_sites)
        log_likes[i] = log(matrix_product(site_msgs[i],pi_col))

    // First integrate out the states so we get the rate likelihoods
    rate_likes = Real[n_rate_cats][n_sites]
    for (i in 1:n_rate_cats) {
        for (j in 1:n_sites) {
            rate_likes[i][j] = matrix_product(rate_msgs[i][j], pi_col)

    // Now compute log likelihoods. We are slicing columns out of rate_likes, and assume that they
    // will represent column vectors
    log_likes = Real[n_sites]
    for (i in 1:n_sites)
        log_likes[i] = log(matrix_product(pi*rate_likes[i]))

    // Weight sample according to the log likelihood
    factor (sum(log_likes))

    // Finally compute site rate esimates. We are slicing columns out of the rate likes, and assume that
    // they will represent column vectors.
    rate_estimates = Real[n_sites]
    for (i in 1:n_sites)
        rate_estimates[i] = cat_rates * normalize(rate_likes[i])

    return Sample(stationary_probs=pi, exchangeability_rates=er, site_rates=rate_estimates)
}

