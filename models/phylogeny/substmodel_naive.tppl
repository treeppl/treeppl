// Hypothetical TreePPL script for inference substitution
// model parameters of the GTR + Gamma model for a fixed
// tree. Here we use the natural ("naive") specification of
// the inference problem

// DATA

// Data is a matrix of type character, with each row
// consisting of the aligned DNA sequence for a single
// taxon. The nucleotide is specified as
//   "A" for adenine
//   "C" for cytosine
//   "G" for guanine
//   "T" for thymine
//   "?" for any of the above
//   "-" a gap, usually treated the same as "?"
// IUPAC has single-character codes for all possible
// combinations of the four nucleotides, but typically
// only those given above are used.
data = [ ["C", "C", "A", "G", "T", "A", "A", "A", "A", "T", "C", "C", "T", "T", "G"],
         ["C", "C", "A", "G", "A", "C", "A", "A", "A", "T", "C", "A", "C", "C", "A"],
         ["A", "A", "C", "C", "A", "G", "C", "A", "A", "A", "G", "A", "T", "T", "A"],
         ["A", "A", "C", "C", "A", "T", "A", "C", "A", "A", "G", "G", "T", "C", "A"]]

// TYPES

// A message is simply four Real values corresponding to the conditional likelihoods
// (unscaled probabilities) of the four different states (A, C, G, T).
type Message = Real[4]

type Tree =
    | Leaf(age: Real, index: Int)
    | Node(age: Real, left: Tree, right: Tree)

// For now, the type RateMatrix can be treated
// as a Real matrix, but we might want to give
// it additional properties in the future
type RateMatrix = Real[][]


// MODEL FUNCTIONS

// A help function to compute the scaled rate matrix for GTR
function gtr(pi:Real[], r:Real[]) : RateMatrix {

    // Construct a matrix of exchangeability rates

    unscaled_q = [ [ -(pi[2]*r[1]+pi[3]*r[2]+pi[4]*r[3]),                          pi[2]*r[1],                          pi[3]*r[2],                          pi[4]*r[3] ],
                   [                          pi[1]*r[1], -(pi[1]*r[1]+pi[3]*r[4]+pi[4]*r[5]),                          pi[3]*r[4],                          pi[4]*r[5] ],
                   [                          pi[1]*r[2],                          pi[2]*r[4], -(pi[1]*r[2]+pi[2]*r[4]+pi[4]*r[6]),                          pi[4]*r[6] ],
                   [                          pi[1]*r[3],                          pi[2]*r[5]],                         pi[3]*r[6], -(pi[1]*r[3]+pi[2]*r[5]+pi[3]*r[6]) ] ]

    scaler = 0.0
    for (i in 1:nrow(rates))
        scaler+= -(unscaled_q[i][i] * pi[i]: RateMatrix )

    return unscaled_q * (1.0/scaler)
}

// We need a function translating observations to observed sequences for leaves.
// See tree inference script for more comments.
function observe_model(seq_data: Character[]) : Int[] {

    seq = Int[length(seq_data)]

    for (i in 1:length(seq_data)) {

        switch(seq_data[i]) :
            case "A" : seq[i] = 0
            case "C" : seq[i] = 1
            case "G" : seq[i] = 2
            case "T" : seq[i] = 3
            case "?", case "-" : assume seq[i] ~ Categorical([0.25,0.25,0.25,0.25],[0,1,2,3])
            default : ERROR("Input data incorrect")
    }
    return seq
}

// Evolve sequences over the tree in postorder fashion using
// automatically matched propose and update statements
function evolve_sequences(data: Character[][], tree, clock_rate, q, pi, site_rates) {

    if (tree is Leaf)
        return observe_model(data[tree.index])

    left_seq  = evolve_sequences(data, tree.left , clock_rate, q, pi, site_rates)
    right_seq = evolve_sequences(data, tree.right, clock_rate, q, pi, site_rates)

    propose seq ~iid(ncol(data), Categorical(probs=pi,values=[0,1,2,3]))
    
    for (i in 1:length(seq)) {
        if (tree.left is Node)
            update left_seq[i]  ~ CTMC(seq[i], q, site_rates[i]*clock_rate)
        if (tree.right is Node)
            update right_seq[i] ~ CTMC(seq[i], q, site_rates[i]*clock_rate)
    }

    return seq
}


// MODEL

function model(data: Character[][], tree: Tree, clock_rate: Real) : type Sample(stationary_probs: Real[], exchangeability_rates: Real[], site_rates: Real[])
{
    // Sample stationary probs and exchangeability rates and
    // compute the  scaled rate matrix for the GTR model.
    
    // We assume nucleotides (A,C,G,T) represented by ints (0,1,2,3)
    assume pi ~ Dirichlet(alpha=[1,1,1,1],values=[0,1,2,3])     
    
    // We assume exchangeability rates being [r_AC, r_AG, r_AT, r_CG, r_CT, r_GT]
    // according to convention
    assume er ~ Dirichlet(alpha=[1,1,1,1,1,1],values=seq(1,6))

    q = gtr(pi, er) // compute the rate matrix

    // Assume a discrete approximation of gamma for rates across sites
    // Using R syntax for the quantiles of the exponential distribution
    assume alpha ~ Exponential(10)
    cat_rates = [qgamma(p=0.125,k=alpha,theta=1./alpha),
                 qgamma(p=0.375,k=alpha,theta=1./alpha),
                 qgamma(p=0.625,k=alpha,theta=1./alpha),
                 qgamma(p=0.875,k=alpha,theta=1./alpha)]
    cat_probs = [0.25, 0.25, 0.25, 0.25]
    site_rates ~iid(ncol(data), Categorical(cat_probs,cat_rates))   // This must be delayed or it will be very inefficient

    // Evolve sequences stepwise in backward fashion using matched propose and update
    // Finally update the root sequence from the prior. Strictly speaking, this is
    // not necessary if the propose and the update are using the same distribution,
    // as they are here.
    root_seq = evolve_sequences(data, tree, clock_rate, q, pi, site_rates)
    update root_seq ~iid(ncol(data), Categorical(pi,[0,1,2,3]))

    return Sample(stationay_probs=pi, exhangeability_rates=er, site_rates=site_rates)
}

