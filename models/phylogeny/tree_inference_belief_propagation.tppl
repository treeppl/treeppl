// Hypothetical TreePPL script for tree inference under the
// Jukes Cantor model with a strict clock prior. This is
// the version having belief propagation hacked in for
// efficiency. Without further modification, the inference
// is still inefficient but the algorithm matches the
// Bouchard-Cote algorithm from 2012 for the Jukes Cantor
// and equal rates case.

// DATA

// Data is a matrix of type character, with each row
// consisting of the aligned DNA sequence for a single
// taxon. The nucleotide is specified as
//   "A" for adenine
//   "C" for cytosine
//   "G" for guanine
//   "T" for thymine
//   "?" for any of the above
//   "-" a gap, usually treated the same as "?"
// IUPAC has single-character codes for all possible
// combinations of the four nucleotides, but typically
// only those given above are used.
data =  [ ["C", "C", "A", "G", "T", "A", "A", "A", "A", "T", "C", "C", "T", "T", "G"],
         ["C", "C", "A", "G", "A", "C", "A", "A", "A", "T", "C", "A", "C", "C", "A"],
         ["A", "A", "C", "C", "A", "G", "C", "A", "A", "A", "G", "A", "T", "T", "A"],
         ["A", "A", "C", "C", "A", "T", "A", "C", "A", "A", "G", "G", "T", "C", "A"]]

// TYPES

// A message is simply four Real values corresponding to the conditional likelihoods
// (unscaled probabilities) of the four different states (A, C, G, T).
type Message = Real[4]

type Tree =
    | Leaf(age: Real, index: Int, msg: Message)
    | Node(age: Real, msg: Message, left: Tree, right: Tree)

// For now, the type RateMatrix can be treated
// as a Real matrix, but we might want to give
// it additional properties in the future
type RateMatrix = Real[][]


// MODEL FUNCTIONS

// A simple help function to compute a message for a branch in the tree in a
// postorder traversal towards the root. We assume standard conventions here
// for the structure of q with respect to time (rows = from-states)
function message(start_msg: Message[], q: RateMatrix, time: Real) : Message[]
{
    trans_matrix = transpose(matrix_exponential(q*time))

    // Assuming that a vector is treated as a row vector in matrix operations
    end_msg = Message[length(start_msg)]
    for (i=1 to length(end_msg))    // Using R-like syntax for illustration, we need to sequence length here
        end_msg[i] = matrix_multiplication(start_msg[i],trans_matrix)

    return end_msg
}

// This is the recursive function that builds the tree backwards in time using
// a random coalescent process.
function cluster(q: RateMatrix, trees: tree[], max_age: Real) : tree[]
{
    // Termination check
    if (length(trees) == 1)
        return trees

    // Randomly sample two indices in the trees vector
    // We will combine these
    pair = sample(2,1:length(trees))    // Using R syntax to illustrate

    // Get convenient names for the selected trees
    left_child  = trees[pair[1]]
    right_child = trees[pair[2]]

    // Get the age of the new node
    assume t ~ Exponential(rate=10.0)
    age = max_age + t

    // It will be useful to know the length of the aligned sequences
    seq_len = length(left_child.seq)

    // Get the output message of the new node with respect to the root of the final tree
    // In principle, same code as used in host-repertoire for belief propagation but
    // arranged a little bit differently
    msg = element_wise_product (message(q, age-left_child.age), message(q,age-right_child.age))

    // Now we want to factor according to the message we just computed, with state probs weighted
    // in some suitable fashion, e.g., by the stationary probs, which are [0.25,0.25,0.25,0.25] for
    // the Jukes Cantor model. This has the additional advantage that this is the standard assumption
    // for the root sequence in the tree, that is, we are assuming stationarity at the root.
    // Assuming here that vectors are naturally row vectors (as opposed to R)
    stationary_probs = transpose([0.25,0.25,0.25,0.25])
    log_likes = Real[length(msg]
    for (i in 1:length(msg))
        log_likes[i] = log(matrix_multiplication(msg[i]*stationary_probs))
    factor (sum(log_likes))
    
    // Combine picked pair of trees into a new node
	parent = Node(age=age, msg=msg, left = left_child, right=right_child)

	// Compute new_trees list
    // Using R syntax to illustrate
    new_trees = c(trees[-ordered_pair],parent)

	// cluster new_trees
	cluster(q, new_trees, age)
}
   
// We need a function computing the message for leaves.
function observe_message(seq_data: Character[]) : Message[] {

    msg = Message[length(seq_data)]

    for (i in 1:length(seq_data)) {

        switch(seq_data[i]) :
            case "A" : msg[i] = [1.0, 0.0, 0.0, 0.0]
            case "C" : msg[i] = [0.0, 1.0, 0.0, 0.0]
            case "G" : msg[i] = [0.0, 0.0, 1.0, 0.0]
            case "T" : msg[i] = [0.0, 0.0, 0.0, 1.0]
            case "?", case "-" : msg[i] = [1.0, 1.0, 1.0, 1.0]
            default : ERROR("Input data incorrect") 
    }
    return msg;
}

// MODEL

function model(data: Character[][]) : Tree
{
    // Define the scaled rate matrix for Jukes-Cantor
    q = [[     -1.0, (1.0/3.0), (1.0/3.0), (1.0/3.0)],
         [(1.0/3.0),      -1.0, (1.0/3.0), (1.0/3.0)],
         [(1.0/3.0), (1.0,3.0),      -1.0, (1.0/3.0)],
         [(1.0/3.0), (1.0/3.0), (1.0/3.0),      -1.0]]

    // Define the initial trees vector (containing leaves)
    // This should be done in a more functional style eventually
    // Now illustrated in an R-like way
    leaves = Tree[nrow(data)]
    for (i in 1:nrow(data))
        leaves[i] = Leaf(age=0.0, index=i, seq = observe_message(data[0]))
    
    // Build the tree by random clustering and return it (first element in return value)
    // Note that the cluster function weights the final tree correctly through its
    // factor statements.
    return cluster(q, trees, 0.0)[1]
}

