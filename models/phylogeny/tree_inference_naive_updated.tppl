// Naive TreePPL script for tree inference under the
// Jukes Cantor model with a strict clock prior. This is
// the naive version; for effective inference, belief
// propagation needs to be implemented in the back end.

// Run this by compiling: 
// tpplc models/phylogeny/tree_inference_naive_updated.tppl -m 'smc-bpf' --resample align --output testphylo
// And then execution 1000 particles 1 sweep, using toy dataset phylo.json:
// ./testphylo models/data/phylo.json 1000 1 > testphylo_output.json

// Toy dataset as json file phylo.json. NOTE this should be nucleotides in later version, currently integers
// Data is a matrix of type int, with each row
// consisting of the aligned DNA sequence for a single
// taxon. The nucleotide is specified as
//   "A" for adenine 0
//   "C" for cytosine 1
//   "G" for guanine 2
//   "T" for thymine 3

// TYPES

type SeqTree =
  | Leaf {age: Real, seq: Int[]}
  | Node {left: SeqTree, right: SeqTree, age: Real, seq: Int[]}

// FUNCTIONS

// Randomly sample two indices in the trees vector, to be combined
function pickpair(n: Int): Int[]
{ 
    assume i ~ Categorical(rep(n,1./Real(n))); // Adjusted to Real(n) 
    assume j ~ Categorical(rep(n,1./Real(n))); // Adjusted to Real(n) 
    if (eqi(j,i)) {
        return pickpair(n); 
    }
    return [addi(i,1),addi(j,1)]; //adding 1 to avoid index 0
}

function ctmc(initialstate: Int, q: Tensor[Real], t: Real): Real[]
{ 
    let choices = [[1.0,0.0,0.0,0.0],[0.0,1.0,0.0,0.0],[0.0,0.0,1.0,0.0],[0.0,0.0,0.0,1.0]]; 
    let state = rvecCreate(4,choices[addi(initialstate,1)]); 
    let p = state*@(mtxExp(q*$t)); //Adjusted () ambiguity
    return[mtxGet(1,1,p),mtxGet(1,2,p),mtxGet(1,3,p),mtxGet(1,4,p)];
}

function cluster(q: Tensor[Real], trees: SeqTree[], maxAge: Real, seq_len: Int): SeqTree[]
{
    let n = length(trees);

    // Check that we have not yet reached the root of the tree
    if (eqi(n, 1)) {
        return trees;
    }
    // Randomly sample two indices in the trees vector with function pickpair
    // We will combine these, named left and right child
    let pairs = pickpair(n);
    let left_child = trees[pairs[1]];
    let right_child = trees[pairs[2]];

    // Get the age of the new internal node
    assume t ~ Exponential(10.0);
    let age = maxAge + t;
    
    // Propose ancestral state(s) from stationary distribution, to be corrected later
    let seq = iid(categorical,CategoricalParam{probs=[0.25,0.25,0.25,0.25]},seq_len);
    
    // Observe the child states given the proposed state of parent node
    for i in 1 to seq_len {
        let p1 = ctmc(seq[i], q, age-left_child.age);
        observe left_child.seq[i] ~ Categorical(p1);
        if (left_child is Node) {
            logWeight -(categoricalLogScore(left_child.seq[i],CategoricalParam{probs=[0.25,0.25,0.25,0.25]})); 
        }  
        let p2 = ctmc(seq[i], q, age-right_child.age);
        observe right_child.seq[i] ~ Categorical(p2);
        if (right_child is Node) {
            logWeight -(categoricalLogScore(right_child.seq[i],CategoricalParam{probs=[0.25,0.25,0.25,0.25]}));
        }  
    }

    // Combine picked pair of trees into a new node
    let parent = Node{age=age, seq=seq, left=left_child, right=right_child};  

    // Compute new_trees list
    let min = mini(pairs[1],pairs[2]);  
    let max = maxi(pairs[1],pairs[2]); 
    let new_trees = join([slice(trees,1,min),slice(trees,addi(min,1),max),slice(trees,addi(max,1),addi(n, 1)),[parent]]);

    // Recursive call to cluster for new_trees
    return cluster(q, new_trees, age, seq_len);
}

// MODEL

model function myModel(data: Int[][]) : SeqTree[]
{
    // Define the scaled rate matrix for Jukes-Cantor
    let q = mtxCreate(4,4,
        [     -1.0, (1.0/3.0), (1.0/3.0), (1.0/3.0),
        (1.0/3.0),      -1.0, (1.0/3.0), (1.0/3.0),
        (1.0/3.0), (1.0/3.0),      -1.0, (1.0/3.0),
        (1.0/3.0), (1.0/3.0), (1.0/3.0),      -1.0]
        );        

    // Define the initial trees vector (containing the leaves)
    // NOTE need to add the function observe_model that replaces A,C,G,T with integers and handles uncertain positions. 
    // Currently input data are integers, and hard coded starting point below.
    let trees = [
        Leaf{age=0.0, seq=data[1]},
        Leaf{age=0.0, seq=data[2]},
        Leaf{age=0.0, seq=data[3]},
        Leaf{age=0.0, seq=data[4]}
    ];

    let seq_len = 15; //This is because length() has bug, to be fixed. 

    // Build the tree by random clustering and return it (second element in return value)
    return cluster(q, trees, 0.0, seq_len);
}