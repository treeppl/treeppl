// Hypothetical TreePPL script for tree inference under the
// Jukes Cantor model with a strict clock prior. This is
// the naive version; for effective inference, belief
// propagation needs to be implemented in the back end.

// The initial aim is to convert this type of script in
// the back end to the belief propagation version

// DATA as json file phylo.json
// Data is a matrix of type character, with each row
// consisting of the aligned DNA sequence for a single
// taxon. The nucleotide is specified as
//   "A" for adenine 1
//   "C" for cytosine 2
//   "G" for guanine 3
//   "T" for thymine 4

// NOTE have removed the function observe_model that replaces A,C,G,T with integers and handles uncertain positions. 
// To be fixed later.

// TYPES

type SeqTree =
  | Leaf {age: Real, seq: Int[]}
  | Node {left: SeqTree, right: SeqTree, age: Real, seq: Int[]}

// FUNCTIONS

// Randomly sample two indices in the trees vector, to be combined
function pickpair(n: Int): Int[]
{ 
    assume i ~ Categorical(rep(n,1./n));
    assume j ~ Categorical(rep(n,1./n));
    if (eqi(j,i)) {
        return f(n); 
    }
    return [i,j];
}

function ctmc(initialstate: Int, q: Tensor[Real], t: Real): Real[]
{ 
    let choices = [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]];
    let state = rvecCreate(choices[initialstate]);
    let p = state*@mtxExp(q*$t);
    return[mtxGet(1,1,p),mtxGet(1,2,p),mtxGet(1,3,p),mtxGet(1,4,p)];
}

function cluster(q: Tensor[Real], trees: SeqTree[], maxAge: Real): SeqTree[]
{
    let n = length(trees);
    // Check that we have not yet reached the root of the tree
    if (eqi(n, 1)) {
        return trees;
    }
    
    // Randomly sample two indices in the trees vector with function f
    // We will combine these, names left and right
    let pairs = pickpair(n);
    let left_child = trees[pairs[1]];
    let right_child = trees[pairs[2]];
    
    // Get the age of the new internal node
    assume t ~ Exponential(10.0);
    let age = maxAge + t;

    // Propose ancestral state(s) from stationary distribution, to be corrected later
    let seq_len = length(left_child.seq); //Find out the length of the aligned sequences
    let seq = iid(categorical,CategoricalParam{probs=[0.25,0.25,0.25,0.25]},seq_len);

    // Observe the child states given the proposed state of parent node
    for (i in 1 to seq_len) {
        let p1 = ctmc(seq[i], q, age-left_child.age);
        observe left_child.seq[i] ~ Categorical(p1);
        if (left_child is Node) {
            logWeight -categoricalLogScore(left_child.seq[i],CategoricalParam{probs=[0.25,0.25,0.25,0.25]});
        }  
        let p2 = ctmc(seq[i], q, age-right_child.age);
        observe right_child.seq[i] ~ Categorical(p2);
        if (right_child is Node) {
            logWeight -categoricalLogScore(right_child.seq[i],CategoricalParam{probs=[0.25,0.25,0.25,0.25]});
        }  
    }
    
    // Combine picked pair of trees into a new node
    let parent = Node{age=age, seq=seq, left=left_child, right=right_child};  

    // Compute new_trees list
    let min = mini(i,j);
    let max = maxi(i,j);
    let new_trees = join([subs(trees,1,min),subs(trees,min+1,max),subs(trees,max+1,n+1),[parent]]);

    // Recursive call to cluster for new_trees
    return cluster(q, new_trees, age);
}

// MODEL
function model(data: Int[][]) : SeqTree
{
    // Define the scaled rate matrix for Jukes-Cantor
    q = [[     -1.0, (1.0/3.0), (1.0/3.0), (1.0/3.0)],
         [(1.0/3.0),      -1.0, (1.0/3.0), (1.0/3.0)],
         [(1.0/3.0), (1.0,3.0),      -1.0, (1.0/3.0)],
         [(1.0/3.0), (1.0/3.0), (1.0/3.0),      -1.0]];

    // Define the initial trees vector (containing the leaves)
    trees = SeqTree[nrow(data)];
    for (i in 1 in nrow(data)) {
        trees[i] = Leaf(age=0.0, seq=data[i]);
    }
    
    // Build the tree by random clustering and return it (first element in return value)
    return cluster(q, trees, 0.0)[1]
}


