/*
 * File: tensors.tppl
 * Description: This program illustrates how to work with tensors.
 * Compilation:
 *   tpplc models/lang/tensors.tppl
 * Execution: ./out models/data/tensors.json 1 1
 */


/*
 * Model function `tensors`
 * Parameters: 
 *  magic: the Int[] sequences of the Melancolia 4x4 magic square
 * Returns: a tensor
 * Side-effect: prints things
 *
 * This function illustrates how to create tensors and manipulate them.
 * Tensors can be over elementary types: Tensor[Real], Tensor[Int], Tensor[Bool],
 * but for linear algebra (matrix algebra) we use real tensors.
 * 
 */
model function tensors(magic: Int[]): Tensor[Real] {
  /* NOTE(vsenderov, 2023-09-27): for now, tensors cannot be read through the
    interface.  To create a tensor, you need to convert it from a sequence. */

  let magicRealSequence = sapply(magic, int2real); // convert to a real sequence
  let magicTensor = mtxCreate(4, 4, magicRealSequence); // create the matrix
  printMtx(magicTensor); // you can print matrices like this

  /***** Functions that help us contruct sequences and matrices *****/
  let rangeTest = 1 to 9; // [1, 2, 3, 4, 5, 6, 7, 8, 9]
  printLn(int2string(rangeTest[7])); // 7
  let rangeReal = sint2real(rangeTest); // you can also convert with sint2real

  let thrByThr = mtxCreate(3, 3, rangeReal);
  printMtx(thrByThr);

  // You can repeat stuff to make a sequence
  let mseq = rep(5, 10.0); // [10.0, 10.0, ... 20 times]
  printLn(paste(sreal2string(mseq)
               , ", " 
               )
         ); // convert the real sequence to a string sequence, 
            // and then join everything together
  let m1 = mtxCreate(1, 5, mseq);
  printMtx(m1);

  // Finally you can create an identity matric
  printLn("ID MATRIX");
  let m2 = mtxCreateId(5);
  printMtx(m2);

  /***** Vectors *****/
  // Vectors are just matrices, one of whose dimensions is one.
  // For example, m1 above is a vector (a row vector).
  // Let's create another two more (a column and a row vector). */
  
  let x = [1.0, 2.0, 3.0, 4.0, 5.0];
  let y = rvecCreate(5, x); // Creates a row vector 1 x 5
  printMtx(y);

  let z = cvecCreate(5, x); // Creates a column vector 5 x 1
  printMtx(z);

  /**** Linear algebra *****/
  // matrix multiplication
  let m1xZ = mtxMul(m1, z); // (1 x 5) x (5 x 1) --> 1x1
  printMtx(m1xZ);

  // you can use special syntax for matrix multiplication
  let m2xY = y %*% m2  ; // (1 x 5) x (5 x 5) --> 1 x 5
  printMtx(m2xY);

  /* NOTE(vsenderov, 2023-09-23): Note that the special syntax will eventually
     be changed to regular syntax, i.e. just `*`.
     Also note that shape error will happen unfortunately at run time. */

  // Raising a matrix to an integer power -- P^n
  let m = mtxCreate(2, 2, [3.14, 3.14, 2.78, 2.78]);
  let m4 = mtxPow(m, 4);
  printMtx(m4);

  // we can also use a syntax
  printMtx( m .^ 4 );

  // Matrix addition
  printMtx( mtxAdd(y, y) );
  // printMtx( mtxAdd(y, z) );
  // will generate a runtime mismatch Matrices dimensions do not match!
  // Also mtxAdd is not implemented in Miking but in Tppl itself,
  // so perhaps it is not very performant
  
  // TODO matrix scalar multiplication

  // TODO matrix transpose
   
  // TODO matrix exponentiation

  // doesn't work
  // let yy = vecToSeqExn(y);

  // Setting stuff   -- use with caution
  mtxSet(1, 1, m2xY, 100.32);

  // Gettinng stuff
  let myScalar = mtxGet(1, 1, m2xY);
  printLn(real2string(myScalar));

  return magicTensor ;
}