type MsgTree =
  | Leaf {age: Real, index: Int, msg: Matrix[Real][][]}   // [cat][site]
  | Node {age: Real, msg: Matrix[Real][][], left: MsgTree, right: MsgTree}


// FUNCTIONS

  // A help function to compute the scaled rate matrix for GTR
  function gtr(pi: Real[], r: Real[]) => Matrix[Real] {
    // Construct a matrix of exchangeability rates
    let unscaled_q = mtxCreate(4,4, 
                     [ -(pi[2]*r[1]+pi[3]*r[2]+pi[4]*r[3]),      pi[2]*r[1],                            pi[3]*r[2],                             pi[4]*r[3] ,
                        pi[1]*r[1],                             -(pi[1]*r[1]+pi[3]*r[4]+pi[4]*r[5]),    pi[3]*r[4],                             pi[4]*r[5] ,
                        pi[1]*r[2],                             pi[2]*r[4],                             -(pi[1]*r[2]+pi[2]*r[4]+pi[4]*r[6]),    pi[4]*r[6] ,
                        pi[1]*r[3],                              pi[2]*r[5],                            pi[3]*r[6],                            -(pi[1]*r[3]+pi[2]*r[5]+pi[3]*r[6])  
                    ]); 

    let scaler_1 = -(mtxGet(1, 1, unscaled_q) * pi[1]);    
    let scaler_2 = -(mtxGet(2, 2, unscaled_q) * pi[2]);
    let scaler_3 = -(mtxGet(3, 3, unscaled_q) * pi[3]);
    let scaler_4 = -(mtxGet(4, 4, unscaled_q) * pi[4]);
    let scaler = scaler_1 + scaler_2 + scaler_3 + scaler_4;

   return mtxSclrMul((1.0/scaler), unscaled_q);
  }   

  // Randomly sample two indices in the trees vector, to be combined. Avoiding mirror cases.
  function pickpair(n: Int) => Int[] {
    assume i ~ Categorical(rep(n, 1./Real(n)));
    let i = i + 1;
    assume j ~ Categorical(rep((n-1), 1./Real((n-1))));
    let j = j+1;
    if (j < i) { return [i, j];}
    else { return [i,j+1];}
  }

  // One site â†’ row-vector; keeps leaf logWeight(pi[state])
  function get_leaf_row(seq: Int, pi: Real[])  => Matrix[Real] {
    if (seq==0) { logWeight (log(pi[1])); return rvecCreate(4, [1.0,0.0,0.0,0.0]); } // A
    if (seq==1) { logWeight (log(pi[2])); return rvecCreate(4, [0.0,1.0,0.0,0.0]); } // C
    if (seq==2) { logWeight (log(pi[3])); return rvecCreate(4, [0.0,0.0,1.0,0.0]); } // G
    if (seq==3) { logWeight (log(pi[4])); return rvecCreate(4, [0.0,0.0,0.0,1.0]); } // T
    if (seq==4) { return rvecCreate(4, [1.0,1.0,1.0,1.0]); }                         // gap
    return error("Invalid state at leaf");
  }
  
  // Replicate per-site rows across the 4 categories
  function replicate4(rows: Matrix[Real][]) => Matrix[Real][][] {
    return [rows, rows, rows, rows];
  }
  
  // Create initial set of leaves - the "forest"
  function build_forest(data: Int[][], forest: MsgTree[], index: Int, data_len: Int, seq_len: Int, pi: Real[]) => MsgTree[] { 
    let site_rows = sapply(data[index], get_leaf_row(_, pi));   // [site]   
    let msg4 = replicate4(site_rows);                         // [cat][site]
    let new_leaf = Leaf{age = 0.0, index = index, msg = msg4}; 
    let new_forest = paste0([forest, [new_leaf]]);
    if (data_len == index) { return new_forest; }
    else { return build_forest(data, new_forest, (index+1), data_len, seq_len, pi); }
  }

  // Compute log likelihood for each site
  function get_log_likes(msg: Matrix[Real], pi: Real[]) => Real {
    let stationary_probs = cvecCreate(4, pi); 
    let like = mtxMul(msg, stationary_probs); 
    let log_like = log(mtxGet(1, 1, like));
    return log_like;
  } 

  // Combine one site for one category (left/right, then elementwise multiply)
  function combine_site_onecat(left_row: Matrix[Real], right_row: Matrix[Real], tL: Matrix[Real], tR: Matrix[Real]) => Matrix[Real] {
    let l = mtxMul(left_row, tL);
    let r = mtxMul(right_row, tR);
    // elementwise via your site-wise helper
    return messageElemMul([l],[r])[1];
  }
  
  // Zip/apply over all sites for one category, recursively
  function zip_apply_onecat(xs: Matrix[Real][], ys: Matrix[Real][], tL: Matrix[Real], tR: Matrix[Real]) => Matrix[Real][] {
    let n = length(xs);
    if (n != length(ys)) { return error("zip_apply_onecat: length mismatch"); }
    if (n == 0) { 
        return []; 
    }
    let head = combine_site_onecat(xs[1], ys[1], tL, tR);
    let tail = zip_apply_onecat(slice(xs,2,n+1), slice(ys,2,n+1), tL, tR);
    return paste0([[head], tail]);
  }
  
  // Merge two subtrees without mixing categories. Returns [cat][site]
  function combine_msgs_allcats(lmsg: Matrix[Real][][], rmsg: Matrix[Real][][],t1L: Matrix[Real], t2L: Matrix[Real], 
    t3L: Matrix[Real], t4L: Matrix[Real],t1R: Matrix[Real], t2R: Matrix[Real], t3R: Matrix[Real], t4R: Matrix[Real]) => Matrix[Real][][] {
    let out1 = zip_apply_onecat(lmsg[1], rmsg[1], t1L, t1R);
    let out2 = zip_apply_onecat(lmsg[2], rmsg[2], t2L, t2R);
    let out3 = zip_apply_onecat(lmsg[3], rmsg[3], t3L, t3R);
    let out4 = zip_apply_onecat(lmsg[4], rmsg[4], t4L, t4R);
    return [out1, out2, out3, out4];
  }

  function pi_col(pi: Real[]) => Matrix[Real] {
      return cvecCreate(4, pi); 
  }

  // One site's log-marginal for a subtree
  function site_log_marginal_from_msg4(msg4_site: Matrix[Real][], pi: Real[], w: Real[]) => Real {
    let p = pi_col(pi);
    let s1 = mtxGet(1,1, mtxMul(msg4_site[1], p));
    let s2 = mtxGet(1,1, mtxMul(msg4_site[2], p));
    let s3 = mtxGet(1,1, mtxMul(msg4_site[3], p));
    let s4 = mtxGet(1,1, mtxMul(msg4_site[4], p));
    return log(w[1]*s1 + w[2]*s2 + w[3]*s3 + w[4]*s4);  // For long alignments, this may need changing? scaling approach.
  }

  // Map over all sites recursively 
  function loglikes_from_msg4(
    msg4: Matrix[Real][][], pi: Real[], w: Real[]) => Real[] {
    let n = length(msg4[1]);        // n: number of sites
    if (n == 0) { 
      return []; 
    }
    let head = site_log_marginal_from_msg4([msg4[1][1], msg4[2][1], msg4[3][1], msg4[4][1]], pi, w);
    let tail = loglikes_from_msg4([slice(msg4[1],2,n+1), slice(msg4[2],2,n+1), slice(msg4[3],2,n+1), slice(msg4[4],2,n+1)], pi, w);
    return paste0([[head], tail]);
  }


// KEY FUNCTION: CLUSTER
function cluster(q: Matrix[Real], trees: MsgTree[], maxAge: Real, seq_len: Int, pi: Real[], rates_cat: Real[], weights: Real[]) => MsgTree[] {
    
    let n = length(trees);
    
    // Check if we have reached the root of the tree
    if ((n==1)) {
        return trees;
    }

    // Randomly sample two indices in the trees vector with function pickpair
    // We will combine these, named left and right child
    let pairs = pickpair(n);
    let left_child = trees[pairs[1]];
    let right_child = trees[pairs[2]];

    // Get the age of the new internal node
    assume t ~ Exponential(10.0);
    let age = maxAge + t;

     // time deltas
    let deltaL = age - left_child.age;
    let deltaR = age - right_child.age;

    // build T_k for each branch
    let t1L = mtxTrans(mtxExp(mtxSclrMul(rates_cat[1]*deltaL, q)));
    let t2L = mtxTrans(mtxExp(mtxSclrMul(rates_cat[2]*deltaL, q)));
    let t3L = mtxTrans(mtxExp(mtxSclrMul(rates_cat[3]*deltaL, q)));
    let t4L = mtxTrans(mtxExp(mtxSclrMul(rates_cat[4]*deltaL, q)));

    let t1R = mtxTrans(mtxExp(mtxSclrMul(rates_cat[1]*deltaR, q)));
    let t2R = mtxTrans(mtxExp(mtxSclrMul(rates_cat[2]*deltaR, q)));
    let t3R = mtxTrans(mtxExp(mtxSclrMul(rates_cat[3]*deltaR, q)));
    let t4R = mtxTrans(mtxExp(mtxSclrMul(rates_cat[4]*deltaR, q)));

    // category-wise combine; no mix of categories
    let node_msg = combine_msgs_allcats(left_child.msg, right_child.msg,t1L,t2L,t3L,t4L, t1R,t2R,t3R,t4R);

    // weights
    let log_likes_node  = loglikes_from_msg4(node_msg, pi, weights);
    let log_likes_left  = loglikes_from_msg4(left_child.msg, pi, weights);
    let log_likes_right = loglikes_from_msg4(right_child.msg,pi, weights);

    logWeight (seqSumReal(log_likes_node));
    logWeight -(seqSumReal(log_likes_left));
    logWeight -(seqSumReal(log_likes_right));

    // Manual resample
    resample;

    // build parent node
    let parent = Node{age=age, msg=node_msg, left=left_child, right=right_child};

    // Compute new_trees list
    let min = minInt(pairs[2],pairs[1]);
    let max = maxInt(pairs[2],pairs[1]);
    let new_trees = paste0([slice(trees, 1, min), slice(trees, (min+1), max), slice(trees, (max+1), (n+1)), [parent]]);

    // Recursive call to cluster for new_trees
    return cluster(q, new_trees, age, seq_len, pi, rates_cat, weights);
}

// MODEL FUNCTION

model function myModel(data: Int[][])  => MsgTree[] {
  // Sample stationary probs and exchangeability rates [r_AC, r_AG, r_AT, r_CG, r_CT, r_GT]
  assume pi ~ Dirichlet([1.0, 1.0, 1.0, 1.0]);
  assume er ~  Dirichlet([1.0, 1.0, 1.0, 1.0, 1.0, 1.0]);   
    
  let q = gtr(pi, er);     

  let data_len = length(data);
  let seq_len =  length(data[1]);

  // Gamma with fixed alpha = 0.5
  let rates_cat = [0.03338775, 0.25191592, 0.82026848, 2.89442785];     // From R function
  let rates_weights = [0.25,0.25,0.25,0.25];                            // Equal weights

  // Define the initial trees sequence (containing the leaves)
  let trees = build_forest(data, [], 1, data_len, seq_len, pi);

  // Build the tree by random clustering and return 
  return cluster(q, trees, 0.0, seq_len, pi, rates_cat, rates_weights);
}