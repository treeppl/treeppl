// these are obsolete with dist.mc
function sampleBernoulli(p: Real): Bool {
  assume x ~ Bernoulli(p);
  return x;
}


/**
 * 
 * Pretty prints a two-dimensional tensor
 * 
 * @param m matrix
 * @return void
 */
function printMtx(m: Tensor[Real]): () {
  let dimensions = dim(m);
  printLn( join( [ "[[ "
                 , int2string( dimensions[1] )
                 , " x "
                 , int2string( dimensions[2] )
                 , " matrix ]]:" 
                 ]
               )
         );
  for i in 1 to (dimensions[1]) {
    for j in 1 to (dimensions[2]) {
      print(concat(real2string(mtxGet(i, j, m)), "\t"));
    }
    printLn("");
  }
  printLn("");
}


// NOTE(vsenderov, 23-09-29): Probably we can write tests as a model function


/**
 * NOTE(vsenderov, 23-10-01): Commented out because we can't use mtxSet 
   as it leads to 0-CFA to fail
 * Adds two matrices element by element.
 * 
 * TODO(vsenderov, 2023-09-28): Is that the best way to implement the
 * addition function?
 * NOTE(vsenderov, 2023-09-29): I've become even more convinced that this is 
 * a hack.  Creating a syntax for this becomes a very hard proposition as
 * the compiler needs to compile this function first, and to compile it, it
 * needs to have it already as we need to be able to interpret all syntaxes...
 * 
 * @param mtx1 First matrix
 * @param mtx2 Second matrix
 * @return Resultant matrix after addition
 */
// function mtxAdd(mtx1: Tensor[Real], mtx2: Tensor[Real]): Tensor[Real] {
//   let dimensions1 = dim(mtx1);
//   let dimensions2 = dim(mtx2);
  
//   // Check if dimensions of both matrices are the same
//   if !eqi(dimensions1[1], dimensions2[1]) && !eqi(dimensions1[2], dimensions2[2]) {
//     printLn("ERROR: Linear algebra problem -- matrix dimensions do not match!");
//     printMtx(mtx1); 
//     printMtx(mtx2);
//     weight(0.); /* TODO(vsenderov, 2023-09-28): investigate if we need to do more
//                    to stop the execution */
//     return mtxCreateId(1);
//   }

//   // Create a result matrix initialized with zeros
//   let result = mtxCreate(dimensions1[1], dimensions1[2], rep(muli(dimensions1[1], dimensions1[2]) , 0.0));

//   for i in 1 to (dimensions1[1]) {
//     for j in 1 to (dimensions1[2]) {
//       let val1 = mtxGet(i, j, mtx1);
//       let val2 = mtxGet(i, j, mtx2);
//       let sum = val1 + val2;
//       mtxSet(i, j, result, sum);
//     }
//   }

//   return result;
// }
